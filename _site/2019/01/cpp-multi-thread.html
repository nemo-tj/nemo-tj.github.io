<!DOCTYPE html>
<html lang="en-us">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Wall-E</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="stylesheet" href="/assets/css/mobile.css">
    <link rel="stylesheet" href="/assets/css/vendor/syntax.css">
    <link rel="stylesheet" href="/assets/css/vendor/semantic.min.css"/>

    <link rel="shortcut icon" type="image/png" href="/assets/img/logo.png"/>
    <link href="https://fonts.googleapis.com/css?family=Open+Sans|Roboto" rel="stylesheet">
</head>

<body>
    
    <div class="page-wrap">
        <div class="header-wrapper">
    <header>
        <!-- logo and description -->
        
        <nav class="site-nav">
            <div class="left-nav">
                <!-- add titles to all buttons -->
                <div class="ui secondary menu inverted">
                    <a class="item" href="/">
                        Home
                    </a>
                    <a class="item" href="/about.html">
                        About
                    </a>
                    <a class="item" href="/archive.html">
                        Archive
                    </a>
                    <div class="right menu">
                        <div id="head-search" class="ui category search item">
                            <div class="ui transparent icon input">
                                <input placeholder="Search..." type="text" id="search-input" onkeypress="handleKeyPress()">
                                <i class="search link icon" onclick="handleSubmit()"></i>
                            </div>
                        </div>

                        <a class="item" href="http://stallman.org/facebook.html">
                            <i class="wechat link icon"></i>
                        </a>
                        <a class="item" href="https://github.com/nemo-tj">
                            <i class="github link icon"></i>
                        </a>
                        <a class="item" href="/feed.xml">Subscribe</a>
                    </div>
                </div>
            </div>
            <div class="right-nav"></div>
        </nav>
    </header>
</div>
        <main>
            <div class="post-container">
    <center>
        <span class="date">
            01 Jan 2019 
             
        </span>
        <h1 class="post-title">C++11 多线程编程基础</h1>
    </center>
    <div class="ui divider"></div>
    <p>　　在每个c++应用程序中，都有一个默认的主线程，即main函数，在c++11中，我们可以通过创建std::thread类的对象来创建其他线程，每个std :: thread对象都可以与一个线程相关联，只需包含头文件&lt; thread&gt;。可以使用std :: thread对象附加一个回调，当这个新线程启动时，它将被执行。 这些回调可以为函数指针、函数对象、Lambda函数。</p>

<p>　　线程对象可通过std::thread obj(&lt; CALLBACK&gt;)来创建，新线程将在创建新对象后立即开始，并且将与已启动的线程并行执行传递的回调。此外，任何线程可以通过在该线程的对象上调用join()函数来等待另一个线程退出。</p>

<h3 id="1-在c11中创建新线程">1. 在C++11中创建新线程</h3>
<h4 id="11-使用函数指针创建线程">1.1 使用函数指针创建线程：</h4>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//main.cpp</span>
<span class="cp">#include &lt;iostream&gt;
#include &lt;thread&gt;
</span>
<span class="kt">void</span> <span class="nf">thread_function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"thread function excuting"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">threadObj</span><span class="p">(</span><span class="n">thread_function</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Display from MainThread"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">threadObj</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Exit of Main function"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="12-使用函数对象创建线程">1.2 使用函数对象创建线程：</h4>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;thread&gt;
</span>
<span class="k">class</span> <span class="nc">DisplayThread</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="k">operator</span> <span class="p">()()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Display Thread Excecuting"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">threadObj</span><span class="p">((</span><span class="n">DisplayThread</span><span class="p">()));</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Display From Main Thread "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Waiting For Thread to complete"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">threadObj</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Exiting from Main Thread"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="13-cmake-编译和说明">1.3 cmake 编译和说明</h4>
<ul>
  <li>CmakeLists.txt
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmake_minimum_required(VERSION 3.10)
project(Thread_test)
set(CMAKE_CXX_STANDARD 11)
find_package(Threads REQUIRED)
add_executable(Thread_test main.cpp)
target_link_libraries(Thread_test ${CMAKE_THREAD_LIBS_INIT})
</code></pre></div>    </div>
  </li>
  <li>线程 id
每个std::thread对象都有一个相关联的id，
std::thread::get_id() -&gt; 成员函数中给出对应线程对象的id;</li>
</ul>

<p>std::this_thread::get_id() -&gt; 给出当前线程的id，如果std::thread对象没有关联的线程，get_id()将返回默认构造的std::thread::id对象：“not any thread”，std::thread::id也可以表示id。</p>

<h3 id="2-joining和detaching-线程">2. joining和detaching 线程</h3>
<p>　　启动了线程，你需要明确是要等待线程结束(加入式join)，还是让其自主运行(分离式detach)</p>

<h4 id="21-一个是通过调用stdthread对象上调用join函数等待这个线程执行完毕">2.1 一个是通过调用std::thread对象上调用join()函数等待这个线程执行完毕:</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>std::thread threadObj(funcPtr); 
threadObj.join();
</code></pre></div></div>

<p>例如，主线程启动10个线程，启动完毕后，main函数等待他们执行完毕，join完所有线程后，main函数继续执行：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;algorithm&gt;
</span>
<span class="k">class</span> <span class="nc">WorkerThread</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()(){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"Worker Thread "</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="s">"is Excecuting"</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threadList</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">threadList</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">WorkerThread</span><span class="p">()));</span>
    <span class="p">}</span>
    <span class="c1">// Now wait for all the worker thread to finish i.e.</span>
    <span class="c1">// Call join() function on each of the std::thread object</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"Wait for all the worker thread to finish"</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">threadList</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">threadList</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">mem_fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">join</span><span class="p">));</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"Exiting from Main Thread"</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> 
</code></pre></div></div>
<h4 id="22-另一个是detach可以将线程与线程对象分离让线程作为后台线程执行当前线程也不会阻塞了">2.2 另一个是detach可以将线程与线程对象分离,让线程作为后台线程执行,当前线程也不会阻塞了.</h4>

<p>但是detach之后就无法在和线程发生联系了.如果线程执行函数使用了临时变量可能会出现问题,线程调用了detach在后台运行,临时变量可能已经销毁,那么线程会访问已经被销毁的变量，需要在std::thread对象中调用std::detach()函数:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">threadObj</span><span class="p">(</span><span class="n">funcPtr</span><span class="p">)</span>
<span class="n">threadObj</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>
</code></pre></div></div>
<p>　　
调用detach()后，std::thread对象不再与实际执行线程相关联，在线程句柄上调用detach() 和 join()要小心.</p>

<h3 id="3-将参数传递给线程">3. 将参数传递给线程</h3>
<p>　　要将参数传递给线程的可关联对象或函数，只需将参数传递给std::thread构造函数，默认情况下，所有的参数都将复制到新线程的内部存储中。 
　　</p>
<h4 id="31-给线程传递值">3.1 给线程传递值：</h4>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;thread&gt;
</span>
<span class="kt">void</span> <span class="nf">threadCallback</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Passed Number = "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Passed String = "</span> <span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"Sample String"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">threadObj</span><span class="p">(</span><span class="n">threadCallback</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
  <span class="n">threadObj</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="32-给线程传递引用">3.2 给线程传递引用：</h4>

<h5 id="320-直接传引用不改变原来的值">3.2.0 直接传引用不改变原来的值</h5>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;thread&gt;
</span>
<span class="kt">void</span> <span class="nf">threadCallback</span><span class="p">(</span><span class="kt">int</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span><span class="o">&amp;</span> <span class="n">y</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
  <span class="n">y</span><span class="o">++</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Inside Thread x = "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"In Main Thread : Before Thread Start x = "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">threadObj</span><span class="p">(</span><span class="n">threadCallback</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
  <span class="n">threadObj</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"In Main Thread : After Thread Joins x = "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> 
</code></pre></div></div>

<p>输出结果为：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>In Main Thread : Before Thread Start x = 9 
Inside Thread x = 10 
In Main Thread : After Thread Joins x = 9

Process finished with exit code 0 
</code></pre></div></div>
<p>　　
即使threadCallback接受参数作为引用，但是并没有改变main中x的值，在线程引用外它是不可见的。这是因为线程函数threadCallback中的x是引用复制在新线程的堆栈中的临时值，</p>

<h5 id="321-使用stdref可进行修改">3.2.1 使用std::ref可进行修改：</h5>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;thread&gt;
</span>
<span class="kt">void</span> <span class="nf">threadCallback</span><span class="p">(</span><span class="kt">int</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span><span class="o">&amp;</span> <span class="n">y</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
  <span class="n">y</span><span class="o">++</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Inside Thread x = "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"In Main Thread : Before Thread Start x = "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">threadObj</span><span class="p">(</span><span class="n">threadCallback</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
  <span class="n">threadObj</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"In Main Thread : After Thread Joins x = "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>输出结果为： 
In Main Thread : Before Thread Start x = 9 
Inside Thread x = 10 
In Main Thread : After Thread Joins x = 10
Process finished with exit code 0</p>

<h4 id="33-传类的成员函数">3.3 传类的成员函数</h4>

<p>　　指定一个类的成员函数的指针作为线程函数，将指针传递给成员函数作为回调函数，并将指针指向对象作为第二个参数：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;thread&gt;
</span>
<span class="k">class</span> <span class="nc">DummyClass</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">DummyClass</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
  <span class="n">DummyClass</span><span class="p">(</span><span class="k">const</span> <span class="n">DummyClass</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">sampleMemberfunction</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Inside sampleMemberfunction "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">DummyClass</span> <span class="n">dummyObj</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">threadObj</span><span class="p">(</span><span class="o">&amp;</span><span class="n">DummyClass</span><span class="o">::</span><span class="n">sampleMemberfunction</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummyObj</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
  <span class="n">threadObj</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="4-线程间数据的共享与竞争条件">4. 线程间数据的共享与竞争条件</h3>

<p>　　在多线程间的数据共享很简单，但是在程序中的这种数据共享可能会引起问题，其中一种便是竞争条件。当两个或多个线程并行执行一组操作，访问相同的内存位置，此时，它们中的一个或多个线程会修改内存位置中的数据，这可能会导致一些意外的结果，这就是竞争条件。竞争条件通常较难发现并重现，因为它们并不总是出现，只有当两个或多个线程执行操作的相对顺序导致意外结果时，它们才会发生。</p>

<p>　　例如创建5个线程，这些线程共享类Wallet的一个对象，使用addMoney()成员函数并行添加100元。所以，如果最初钱包中的钱是0，那么在所有线程的竞争执行完毕后，钱包中的钱应该是500，但是，由于所有线程同时修改共享数据，在某些情况下，钱包中的钱可能远小于500。</p>

<p>测试如下：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;algorithm&gt;
</span>
<span class="k">class</span> <span class="nc">Wallet</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">mMoney</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Wallet</span><span class="p">()</span> <span class="o">:</span> <span class="n">mMoney</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">int</span> <span class="n">getMoney</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">mMoney</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">addMoney</span><span class="p">(</span><span class="kt">int</span> <span class="n">money</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">money</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">mMoney</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">testMultithreadWallet</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Wallet</span> <span class="n">walletObject</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">threads</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Wallet</span><span class="o">::</span><span class="n">addMoney</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">walletObject</span><span class="p">,</span> <span class="mi">100</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">threads</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">walletObject</span><span class="p">.</span><span class="n">getMoney</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">val</span><span class="o">=</span><span class="n">testMultithreadWallet</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">500</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Error at count = "</span> <span class="o">&lt;&lt;</span> <span class="n">k</span> <span class="o">&lt;&lt;</span> <span class="s">" Money in Wallet = "</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>每个线程并行地增加相同的成员变量“mMoney”，看似是一条线，但是这个“nMoney++”实际上被转换为3条机器命令：</p>

<ul>
  <li>在Register中加载”mMoney”变量</li>
  <li>增加register的值</li>
  <li>用register的值更新“mMoney”变量</li>
</ul>

<p>在这种情况下，一个增量将被忽略，因为不是增加mMoney变量，而是增加不同的寄存器，“mMoney”变量的值被覆盖。所以最终的输出结果并不是5个线程各自叠加了100，即最终的输出结果不一定是 500 ！</p>

<h3 id="5-使用mutex处理竞争条件">5. 使用mutex处理竞争条件</h3>

<p>　　为了处理多线程环境中的竞争条件，我们需要mutex互斥锁，在修改或读取共享数据前，需要对数据加锁，修改完成后，对数据进行解锁。在c++11的线程库中，mutex 在&lt; mutex &gt;头文件中，表示互斥体的类是std::mutex。</p>

<p>　　就上面的问题进行处理，Wallet类提供了在Wallet中增加money的方法，并且在不同的线程中使用相同的Wallet对象，所以我们需要对Wallet的addMoney()方法加锁。在增加Wallet中的money前加锁，并且在离开该函数前解锁，看代码：Wallet类内部维护money，并提供函数addMoney()，这个成员函数首先获取一个锁，然后给wallet对象的money增加指定的数额，最后释放锁。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
#include &lt;mutex&gt;
</span>
<span class="k">class</span> <span class="nc">Wallet</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">mMoney</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Wallet</span><span class="p">()</span> <span class="o">:</span> <span class="n">mMoney</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">int</span> <span class="n">getMoney</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">mMoney</span><span class="p">;}</span>
    <span class="kt">void</span> <span class="n">addMoney</span><span class="p">(</span><span class="kt">int</span> <span class="n">money</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">mutex</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">money</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">mMoney</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">mutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">testMultithreadWallet</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Wallet</span> <span class="n">walletObject</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">threads</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Wallet</span><span class="o">::</span><span class="n">addMoney</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">walletObject</span><span class="p">,</span> <span class="mi">1000</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">threads</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">threads</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">walletObject</span><span class="p">.</span><span class="n">getMoney</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">=</span> <span class="n">testMultithreadWallet</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">5000</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Error at count= "</span> <span class="o">&lt;&lt;</span> <span class="n">k</span> <span class="o">&lt;&lt;</span> <span class="s">" money in wallet"</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这种情况保证了钱包里的钱不会出现少于5000的情况，因为addMoney()中的互斥锁确保了只有在一个线程修改完成money后，另一个线程才能对其进行修改，但是，如果我们忘记在函数结束后对锁进行释放会怎么样？这种情况下，一个线程将退出而不释放锁，其他线程将保持等待，为了避免这种情况，我们应当使用std::lock_guard，这是一个template class，它为mutex实现RALL，它将mutex包裹在其对象内，并将附加的mutex锁定在其构造函数中，当其析构函数被调用时，它将释放互斥体。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Wallet</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">mMoney</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">Wallet</span><span class="p">()</span> <span class="o">:</span> <span class="n">mMoney</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
  <span class="kt">int</span> <span class="n">getMoney</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">mMoney</span><span class="p">;}</span>
  <span class="kt">void</span> <span class="n">addMoney</span><span class="p">(</span><span class="kt">int</span> <span class="n">money</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lockGuard</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mMoney</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">//如果在此处发生异常，lockGuadr的析构函数将会因为堆栈展开而被调用</span>
      <span class="n">mMoney</span><span class="o">++</span><span class="p">;</span>
      <span class="c1">//一旦函数退出，那么lockGuard对象的析构函数将被调用，在析构函数中mutex会被释放</span>
    <span class="p">}</span>

  <span class="p">}</span>
<span class="p">};</span> 
</code></pre></div></div>

<h3 id="6-条件变量">6. 条件变量</h3>

<p>　　条件变量是一种用于在2个线程之间进行信令的事件，一个线程可以等待它得到信号，其他的线程可以给它发信号。在c++11中，条件变量需要头文件&lt; condition_variable&gt;，同时，条件变量还需要一个mutex锁。</p>

<h4 id="61-条件变量是如何运行的">6.1 条件变量是如何运行的：</h4>

<p>　　- 线程1调用等待条件变量，内部获取mutex互斥锁并检查是否满足条件； 
　　- 如果没有，则释放锁，并等待条件变量得到发出的信号(线程被阻塞),条件变量的 wait() 函数以原子方式提供这两个操作；</p>

<p>　　- 另一个线程，如线程2，当满足条件时，向条件变量发信号； 
　　- 一旦线程1正等待其恢复的条件变量发出信号，线程1便获取互斥锁，并检查与条件变量相关关联的条件是否满足，或者是否是一个上级调用，如果多个线程正在等待，那么notify_one将只解锁一个线程； 
　　- 如果是一个上级调用，那么它再次调用wait()函数。 
　　</p>
<h4 id="62-条件变量的主要成员函数">6.2 条件变量的主要成员函数：</h4>
<h5 id="wait">Wait()</h5>
<ul>
  <li>它使得当前线程阻塞，直到条件变量得到信号或发生虚假唤醒；</li>
  <li>它原子性地释放附加的mutex，阻塞当前线程，并将其添加到等待当前条件变量对象的线程列表中，当某线程在同样的条件变量上调用notify_one() 或者 notify_all()，线程将被解除阻塞；</li>
  <li>这种行为也可能是虚假的，因此，解除阻塞后，需要再次检查条件；</li>
  <li>一个回调函数会传给该函数，调用它来检查其是否是虚假调用，还是确实满足了真实条件；</li>
  <li>当线程解除阻塞后，wait()函数获取mutex锁，并检查条件是否满足，如果条件不满足，则再次原子性地释放附加的mutex，阻塞当前线程，并将其添加到等待当前条件变量对象的线程列表中。</li>
</ul>

<h5 id="notify_one">notify_one()</h5>
<p>如果所有线程都在等待相同的条件变量对象，那么notify_one会取消阻塞其中一个等待线程。</p>

<h5 id="notify_all">notify_all()</h5>
<p>如果所有线程都在等待相同的条件变量对象，那么notify_all会取消阻塞所有的等待线程。</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;functional&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Application</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m_mutex</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">m_condVar</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">m_bDataLoaded</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Application</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">m_bDataLoaded</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">loadData</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">//使该线程sleep 1秒</span>
        <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">1000</span><span class="p">));</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Loading Data from XML"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

        <span class="c1">//锁定数据</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">guard</span><span class="p">(</span><span class="n">m_mutex</span><span class="p">);</span>

        <span class="c1">//flag设为true，表明数据已加载</span>
        <span class="n">m_bDataLoaded</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

        <span class="c1">//通知条件变量</span>
        <span class="n">m_condVar</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">isDataLoaded</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_bDataLoaded</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">mainTask</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Do some handshaking"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

        <span class="c1">//获取锁</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">mlock</span><span class="p">(</span><span class="n">m_mutex</span><span class="p">);</span>

        <span class="c1">//开始等待条件变量得到信号</span>
        <span class="c1">//wait()将在内部释放锁，并使线程阻塞</span>
        <span class="c1">//一旦条件变量发出信号，则恢复线程并再次获取锁</span>
        <span class="c1">//然后检测条件是否满足，如果条件满足，则继续，否则再次进入wait</span>
        <span class="n">m_condVar</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">mlock</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Application</span><span class="o">::</span><span class="n">isDataLoaded</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Do Processing On loaded Data"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Application</span> <span class="n">app</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">thread_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Application</span><span class="o">::</span><span class="n">mainTask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">app</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">thread_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Application</span><span class="o">::</span><span class="n">loadData</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">app</span><span class="p">);</span>
    <span class="n">thread_2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">thread_1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />
<p>作者：krais24 
来源：CSDN 
原文：https://blog.csdn.net/krais_wk/article/details/81095899 
版权声明：本文为博主原创文章，转载请附上博文链接！</p>

<h3 id="7-参考文献">7. 参考文献</h3>

<p><a href="http://www.cnblogs.com/haippy/p/3235560.html">http://www.cnblogs.com/haippy/p/3235560.html</a></p>

    <div class="ui horizontal divider">
        Thank You For Reading
    </div>
    <!-- author box -->
<div class="ui segment">
    <div class="ui items">
        <div class="item">
            <a class="ui circular tiny image">
                <img src="/assets/img/profile.jpg">
            </a>
            <div class="content">
                <a class="header">晋戈</a>
                <div class="description">
                    <p>同理心温暖世界，认真设计未来</p>
                </div>
            </div>
        </div>
    </div>
</div>

    <section class="disqus">
    <div id="disqus_thread"></div>
    <script type="text/javascript">

        var disqus_shortname = 'nagekar'; 
        var disqus_developer = 0; // developer mode is on
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>
</div>
        </main>
    </div>
    
    <footer>
    <div class="footer-wrapper">
        <div class="ui secondary menu inverted">
            <p class="item">Wall-E &copy; 2017</p>
            <div class="right menu">
                <a class="item" href="/archive.html">
                    Latest Posts
                </a>
                <a class="item" href="https://twitter.com/fsf">
                    Twitter
                </a>
                <a class="item" href="https://github.com/nemo-tj">
                    Github
                </a>
            </div>
        </div>
    </div>
</footer>
<script type="text/javascript" src="/assets/js/main.js"></script>
<script type="text/javascript" src="/assets/js/vendor/jquery.min.js"></script>
<script type="text/javascript" src="/assets/js/vendor/semantic.min.js"></script>

    <script src="/assets/js/vendor/jquery.min.js"></script>
    <script src="/assets/js/vendor/semantic.min.js"></script>
    <script type="/assets/js/main.js"></script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML">
    </script>
    
</body>

</html>