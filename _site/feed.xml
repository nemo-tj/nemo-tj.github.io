<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wall-E - From Space From Earth</title>
    <description>New Start For New Journey</description>
    <link>//</link>
    <atom:link href="//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 05 Feb 2019 21:16:37 +0800</pubDate>
    <lastBuildDate>Tue, 05 Feb 2019 21:16:37 +0800</lastBuildDate>
    <generator>Jekyll v3.7.3</generator>
    
      <item>
        <title>C++11 多线程编程基础</title>
        <description>&lt;h3 id=&quot;1-在c11中创建新线程&quot;&gt;1. 在C++11中创建新线程&lt;/h3&gt;

&lt;p&gt;　　在每个c++应用程序中，都有一个默认的主线程，即main函数，在c++11中，我们可以通过创建std::thread类的对象来创建其他线程，每个std :: thread对象都可以与一个线程相关联，只需包含头文件&amp;lt; thread&amp;gt;。可以使用std :: thread对象附加一个回调，当这个新线程启动时，它将被执行。 这些回调可以为函数指针、函数对象、Lambda函数。&lt;/p&gt;

&lt;p&gt;　　线程对象可通过std::thread obj(&amp;lt; CALLBACK&amp;gt;)来创建，新线程将在创建新对象后立即开始，并且将与已启动的线程并行执行传递的回调。此外，任何线程可以通过在该线程的对象上调用join()函数来等待另一个线程退出。&lt;/p&gt;

&lt;h4 id=&quot;11-使用函数指针创建线程&quot;&gt;1.1 使用函数指针创建线程：&lt;/h4&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//main.cpp&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;thread&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;thread_function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;thread function excuting&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threadObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;thread_function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Display from MainThread&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;threadObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Exit of Main function&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;/p&gt;
&lt;h4 id=&quot;12-使用函数对象创建线程&quot;&gt;1.2 使用函数对象创建线程：&lt;/h4&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;thread&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DisplayThread&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Display Thread Excecuting&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threadObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DisplayThread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()));&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Display From Main Thread &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Waiting For Thread to complete&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;threadObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Exiting from Main Thread&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;13-cmake-编译和说明&quot;&gt;1.3 cmake 编译和说明&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;CmakeLists.txt&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cmake_minimum_required(VERSION 3.10)
project(Thread_test)
set(CMAKE_CXX_STANDARD 11)
find_package(Threads REQUIRED)
add_executable(Thread_test main.cpp)
target_link_libraries(Thread_test ${CMAKE_THREAD_LIBS_INIT})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;线程 id&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每个std::thread对象都有一个相关联的id，
std::thread::get_id() -&amp;gt; 成员函数中给出对应线程对象的id;&lt;/p&gt;

&lt;p&gt;std::this_thread::get_id() -&amp;gt; 给出当前线程的id，如果std::thread对象没有关联的线程，get_id()将返回默认构造的std::thread::id对象：“not any thread”，std::thread::id也可以表示id。&lt;/p&gt;

&lt;h3 id=&quot;2-joining和detaching-线程&quot;&gt;2. joining和detaching 线程&lt;/h3&gt;
&lt;p&gt;　　启动了线程，你需要明确是要等待线程结束(加入式join)，还是让其自主运行(分离式detach)&lt;/p&gt;

&lt;h4 id=&quot;21-一个是通过调用stdthread对象上调用join函数等待这个线程执行完毕&quot;&gt;2.1 一个是通过调用std::thread对象上调用join()函数等待这个线程执行完毕:&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::thread threadObj(funcPtr); 
threadObj.join();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;例如，主线程启动10个线程，启动完毕后，main函数等待他们执行完毕，join完所有线程后，main函数继续执行：&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;thread&amp;gt;
#include &amp;lt;algorithm&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WorkerThread&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()(){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Worker Thread &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;this_thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;is Excecuting&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threadList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;threadList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WorkerThread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()));&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Now wait for all the worker thread to finish i.e.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Call join() function on each of the std::thread object&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Wait for all the worker thread to finish&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;for_each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;threadList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threadList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mem_fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Exiting from Main Thread&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;22-另一个是detach可以将线程与线程对象分离让线程作为后台线程执行当前线程也不会阻塞了&quot;&gt;2.2 另一个是detach可以将线程与线程对象分离,让线程作为后台线程执行,当前线程也不会阻塞了.&lt;/h4&gt;

&lt;p&gt;但是detach之后就无法在和线程发生联系了.如果线程执行函数使用了临时变量可能会出现问题,线程调用了detach在后台运行,临时变量可能已经销毁,那么线程会访问已经被销毁的变量，需要在std::thread对象中调用std::detach()函数:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::thread threadObj(funcPtr)
threadObj.detach();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;　　
调用detach()后，std::thread对象不再与实际执行线程相关联，在线程句柄上调用detach() 和 join()要小心.&lt;/p&gt;

&lt;h3 id=&quot;3-将参数传递给线程&quot;&gt;3. 将参数传递给线程&lt;/h3&gt;
&lt;p&gt;　　要将参数传递给线程的可关联对象或函数，只需将参数传递给std::thread构造函数，默认情况下，所有的参数都将复制到新线程的内部存储中。 
　　&lt;/p&gt;
&lt;h4 id=&quot;31-给线程传递值&quot;&gt;3.1 给线程传递值：&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;thread&amp;gt;

void threadCallback(int x, std::string str) {
  std::cout &amp;lt;&amp;lt; &quot;Passed Number = &quot; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
  std::cout &amp;lt;&amp;lt; &quot;Passed String = &quot; &amp;lt;&amp;lt; str &amp;lt;&amp;lt; std::endl;
}
int main() {
  int x = 10;
  std::string str = &quot;Sample String&quot;;
  std::thread threadObj(threadCallback, x, str);
  threadObj.join();
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;32-给线程传递引用&quot;&gt;3.2 给线程传递引用：&lt;/h4&gt;

&lt;h5 id=&quot;320-直接传引用不改变原来的值&quot;&gt;3.2.0 直接传引用不改变原来的值&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;thread&amp;gt;

void threadCallback(int const&amp;amp; x) {
  int&amp;amp; y = const_cast&amp;lt;int&amp;amp;&amp;gt;(x);
  y++;
  std::cout &amp;lt;&amp;lt; &quot;Inside Thread x = &quot; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
}

int main() {
  int x = 9;
  std::cout &amp;lt;&amp;lt; &quot;In Main Thread : Before Thread Start x = &quot; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
  std::thread threadObj(threadCallback, x);
  threadObj.join();
  std::cout &amp;lt;&amp;lt; &quot;In Main Thread : After Thread Joins x = &quot; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
  return 0;
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In Main Thread : Before Thread Start x = 9 
Inside Thread x = 10 
In Main Thread : After Thread Joins x = 9

Process finished with exit code 0 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;　　
即使threadCallback接受参数作为引用，但是并没有改变main中x的值，在线程引用外它是不可见的。这是因为线程函数threadCallback中的x是引用复制在新线程的堆栈中的临时值，&lt;/p&gt;

&lt;h5 id=&quot;321-使用stdref可进行修改&quot;&gt;3.2.1 使用std::ref可进行修改：&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;thread&amp;gt;

void threadCallback(int const&amp;amp; x) {
  int&amp;amp; y = const_cast&amp;lt;int&amp;amp;&amp;gt;(x);
  y++;
  std::cout &amp;lt;&amp;lt; &quot;Inside Thread x = &quot; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
}

int main() {
  int x = 9;
  std::cout &amp;lt;&amp;lt; &quot;In Main Thread : Before Thread Start x = &quot; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
  std::thread threadObj(threadCallback, std::ref(x));
  threadObj.join();
  std::cout &amp;lt;&amp;lt; &quot;In Main Thread : After Thread Joins x = &quot; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出结果为： 
In Main Thread : Before Thread Start x = 9 
Inside Thread x = 10 
In Main Thread : After Thread Joins x = 10
Process finished with exit code 0&lt;/p&gt;

&lt;h4 id=&quot;33-传类的成员函数&quot;&gt;3.3 传类的成员函数&lt;/h4&gt;

&lt;p&gt;　　指定一个类的成员函数的指针作为线程函数，将指针传递给成员函数作为回调函数，并将指针指向对象作为第二个参数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;thread&amp;gt;

class DummyClass {
 public:
  DummyClass() { }
  DummyClass(const DummyClass&amp;amp; obj) { }
  void sampleMemberfunction(int x) {
    std::cout &amp;lt;&amp;lt; &quot;Inside sampleMemberfunction &quot; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
  }
};

int main() {
  DummyClass dummyObj;
  int x = 10;
  std::thread threadObj(&amp;amp;DummyClass::sampleMemberfunction, &amp;amp;dummyObj, x);
  threadObj.join();

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;4-线程间数据的共享与竞争条件&quot;&gt;4. 线程间数据的共享与竞争条件&lt;/h3&gt;

&lt;p&gt;　　在多线程间的数据共享很简单，但是在程序中的这种数据共享可能会引起问题，其中一种便是竞争条件。当两个或多个线程并行执行一组操作，访问相同的内存位置，此时，它们中的一个或多个线程会修改内存位置中的数据，这可能会导致一些意外的结果，这就是竞争条件。竞争条件通常较难发现并重现，因为它们并不总是出现，只有当两个或多个线程执行操作的相对顺序导致意外结果时，它们才会发生。&lt;/p&gt;

&lt;p&gt;　　例如创建5个线程，这些线程共享类Wallet的一个对象，使用addMoney()成员函数并行添加100元。所以，如果最初钱包中的钱是0，那么在所有线程的竞争执行完毕后，钱包中的钱应该是500，但是，由于所有线程同时修改共享数据，在某些情况下，钱包中的钱可能远小于500。&lt;/p&gt;

&lt;p&gt;测试如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;thread&amp;gt;
#include &amp;lt;algorithm&amp;gt;

class Wallet {
    int mMoney;
public:
    Wallet() : mMoney(0) { }
    int getMoney() { return mMoney; }
    void addMoney(int money) {
        for (int i = 0; i &amp;lt; money; i++) {
            mMoney++;
        }
    }
};

int testMultithreadWallet() {
    Wallet walletObject;
    std::vector&amp;lt;std::thread&amp;gt; threads;
    for (int i = 0; i &amp;lt; 5; i++) {
        threads.push_back(std::thread(&amp;amp;Wallet::addMoney, &amp;amp;walletObject, 100));
    }
    for (int i = 0; i &amp;lt; 5; i++) {
        threads.at(i).join();
    }
    return walletObject.getMoney();
}

int main() {
    int val = 0;
    for (int k = 0; k &amp;lt; 100; k++) {
        if ((val=testMultithreadWallet()) != 500) {
            std::cout &amp;lt;&amp;lt; &quot;Error at count = &quot; &amp;lt;&amp;lt; k &amp;lt;&amp;lt; &quot; Money in Wallet = &quot; &amp;lt;&amp;lt; val &amp;lt;&amp;lt; std::endl;
        }
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;每个线程并行地增加相同的成员变量“mMoney”，看似是一条线，但是这个“nMoney++”实际上被转换为3条机器命令：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在Register中加载”mMoney”变量&lt;/li&gt;
  &lt;li&gt;增加register的值&lt;/li&gt;
  &lt;li&gt;用register的值更新“mMoney”变量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在这种情况下，一个增量将被忽略，因为不是增加mMoney变量，而是增加不同的寄存器，“mMoney”变量的值被覆盖。所以最终的输出结果并不是5个线程各自叠加了100，即最终的输出结果不一定是 500 ！&lt;/p&gt;

&lt;h3 id=&quot;5-使用mutex处理竞争条件&quot;&gt;5. 使用mutex处理竞争条件&lt;/h3&gt;

&lt;p&gt;　　为了处理多线程环境中的竞争条件，我们需要mutex互斥锁，在修改或读取共享数据前，需要对数据加锁，修改完成后，对数据进行解锁。在c++11的线程库中，mutex 在&amp;lt; mutex &amp;gt;头文件中，表示互斥体的类是std::mutex。&lt;/p&gt;

&lt;p&gt;　　就上面的问题进行处理，Wallet类提供了在Wallet中增加money的方法，并且在不同的线程中使用相同的Wallet对象，所以我们需要对Wallet的addMoney()方法加锁。在增加Wallet中的money前加锁，并且在离开该函数前解锁，看代码：Wallet类内部维护money，并提供函数addMoney()，这个成员函数首先获取一个锁，然后给wallet对象的money增加指定的数额，最后释放锁。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;thread&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;mutex&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Wallet&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mMoney&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Wallet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mMoney&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getMoney&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mMoney&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addMoney&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;money&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;money&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;mMoney&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;testMultithreadWallet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Wallet&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;walletObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threads&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;threads&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Wallet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addMoney&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;walletObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threads&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;threads&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;walletObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getMoney&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testMultithreadWallet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Error at count= &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; money in wallet&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这种情况保证了钱包里的钱不会出现少于5000的情况，因为addMoney()中的互斥锁确保了只有在一个线程修改完成money后，另一个线程才能对其进行修改，但是，如果我们忘记在函数结束后对锁进行释放会怎么样？这种情况下，一个线程将退出而不释放锁，其他线程将保持等待，为了避免这种情况，我们应当使用std::lock_guard，这是一个template class，它为mutex实现RALL，它将mutex包裹在其对象内，并将附加的mutex锁定在其构造函数中，当其析构函数被调用时，它将释放互斥体。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Wallet {
  int mMoney;
  std::mutex mutex;
 public:
  Wallet() : mMoney(0) { }
  int getMoney() { return mMoney;}
  void addMoney(int money) {
    std::lock_guard&amp;lt;std::mutex&amp;gt; lockGuard(mutex);

    for (int i = 0; i &amp;lt; mMoney; ++i) {
      //如果在此处发生异常，lockGuadr的析构函数将会因为堆栈展开而被调用
      mMoney++;
      //一旦函数退出，那么lockGuard对象的析构函数将被调用，在析构函数中mutex会被释放
    }

  }
}; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;6-条件变量&quot;&gt;6. 条件变量&lt;/h3&gt;

&lt;p&gt;　　条件变量是一种用于在2个线程之间进行信令的事件，一个线程可以等待它得到信号，其他的线程可以给它发信号。在c++11中，条件变量需要头文件&amp;lt; condition_variable&amp;gt;，同时，条件变量还需要一个mutex锁。&lt;/p&gt;

&lt;h4 id=&quot;61-条件变量是如何运行的&quot;&gt;6.1 条件变量是如何运行的：&lt;/h4&gt;

&lt;p&gt;　　- 线程1调用等待条件变量，内部获取mutex互斥锁并检查是否满足条件； 
　　- 如果没有，则释放锁，并等待条件变量得到发出的信号(线程被阻塞),条件变量的 wait() 函数以原子方式提供这两个操作；&lt;/p&gt;

&lt;p&gt;　　- 另一个线程，如线程2，当满足条件时，向条件变量发信号； 
　　- 一旦线程1正等待其恢复的条件变量发出信号，线程1便获取互斥锁，并检查与条件变量相关关联的条件是否满足，或者是否是一个上级调用，如果多个线程正在等待，那么notify_one将只解锁一个线程； 
　　- 如果是一个上级调用，那么它再次调用wait()函数。 
　　&lt;/p&gt;
&lt;h4 id=&quot;62-条件变量的主要成员函数&quot;&gt;6.2 条件变量的主要成员函数：&lt;/h4&gt;
&lt;h5 id=&quot;wait&quot;&gt;Wait()&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;它使得当前线程阻塞，直到条件变量得到信号或发生虚假唤醒；&lt;/li&gt;
  &lt;li&gt;它原子性地释放附加的mutex，阻塞当前线程，并将其添加到等待当前条件变量对象的线程列表中，当某线程在同样的条件变量上调用notify_one() 或者 notify_all()，线程将被解除阻塞；&lt;/li&gt;
  &lt;li&gt;这种行为也可能是虚假的，因此，解除阻塞后，需要再次检查条件；&lt;/li&gt;
  &lt;li&gt;一个回调函数会传给该函数，调用它来检查其是否是虚假调用，还是确实满足了真实条件；&lt;/li&gt;
  &lt;li&gt;当线程解除阻塞后，wait()函数获取mutex锁，并检查条件是否满足，如果条件不满足，则再次原子性地释放附加的mutex，阻塞当前线程，并将其添加到等待当前条件变量对象的线程列表中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;notify_one&quot;&gt;notify_one()&lt;/h5&gt;
&lt;p&gt;如果所有线程都在等待相同的条件变量对象，那么notify_one会取消阻塞其中一个等待线程。&lt;/p&gt;

&lt;h5 id=&quot;notify_all&quot;&gt;notify_all()&lt;/h5&gt;
&lt;p&gt;如果所有线程都在等待相同的条件变量对象，那么notify_all会取消阻塞所有的等待线程。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;thread&amp;gt;
#include &amp;lt;functional&amp;gt;
#include &amp;lt;mutex&amp;gt;
#include &amp;lt;condition_variable&amp;gt;
using namespace std::placeholders;

class Application {
    std::mutex m_mutex;
    std::condition_variable m_condVar;
    bool m_bDataLoaded;
public:
    Application() {
        m_bDataLoaded = false;
    }

    void loadData() {
        //使该线程sleep 1秒
        std::this_thread::sleep_for(std::chrono::milliseconds(1000));
        std::cout &amp;lt;&amp;lt; &quot;Loading Data from XML&quot; &amp;lt;&amp;lt; std::endl;

        //锁定数据
        std::lock_guard&amp;lt;std::mutex&amp;gt; guard(m_mutex);

        //flag设为true，表明数据已加载
        m_bDataLoaded = true;

        //通知条件变量
        m_condVar.notify_one();
    }

    bool isDataLoaded() {
        return m_bDataLoaded;
    }

    void mainTask() {
        std::cout &amp;lt;&amp;lt; &quot;Do some handshaking&quot; &amp;lt;&amp;lt; std::endl;

        //获取锁
        std::unique_lock&amp;lt;std::mutex&amp;gt; mlock(m_mutex);

        //开始等待条件变量得到信号
        //wait()将在内部释放锁，并使线程阻塞
        //一旦条件变量发出信号，则恢复线程并再次获取锁
        //然后检测条件是否满足，如果条件满足，则继续，否则再次进入wait
        m_condVar.wait(mlock, std::bind(&amp;amp;Application::isDataLoaded, this));
        std::cout &amp;lt;&amp;lt; &quot;Do Processing On loaded Data&quot; &amp;lt;&amp;lt; std::endl;
    }
};

int main() {
    Application app;
    std::thread thread_1(&amp;amp;Application::mainTask, &amp;amp;app);
    std::thread thread_2(&amp;amp;Application::loadData, &amp;amp;app);
    thread_2.join();
    thread_1.join();

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;p&gt;作者：krais24 
来源：CSDN 
原文：https://blog.csdn.net/krais_wk/article/details/81095899 
版权声明：本文为博主原创文章，转载请附上博文链接！&lt;/p&gt;

&lt;h3 id=&quot;7-参考文献&quot;&gt;7. 参考文献&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/haippy/p/3235560.html&quot;&gt;http://www.cnblogs.com/haippy/p/3235560.html&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 01 Jan 2019 00:00:00 +0800</pubDate>
        <link>//2019/01/cpp-multi-thread.html</link>
        <guid isPermaLink="true">//2019/01/cpp-multi-thread.html</guid>
        
        <category>c++</category>
        
        <category>多线程</category>
        
        
      </item>
    
      <item>
        <title>这一年</title>
        <description>&lt;p&gt;2018年是关于足球和关于世界杯的一年；是关于告别和重启的一年。这一年，我在北京。此刻我在重温着世界杯的淘汰赛，法国对阿根廷的那一场。足坛新星姆巴佩缓缓升起，英雄的球王无力回天。两相对比中，更显落寞和无奈。一如我这折腾的一年，五味杂陈的一年。&lt;/p&gt;

&lt;p&gt;这一年，以换工作开始，以换工作结束。差强人意的生活里，更多的是迷茫和不安。大起大落的18年，经历颇多。从工作到生活，到爱情，到友情，都是冲击和历练。在经历了系列的心理建设后，18年终是走过来。&lt;/p&gt;

&lt;p&gt;在gap了一段时间后，18年，我最终还是走向了社会，走向了工作。心里的那个关于学术和创造的梦想，也在生活的推动下，不得不搁置。讲真，上班比上学轻松很多，这样的生活真的很惬意。接需求，写代码，测试，上线，分析，写报表。除了刚开始时候的陌生，真的过得很舒适，舒适的甚至都让我感到迷恋。暑假的时候，二哥来北京，在我的小出租屋里，我无比骄傲的给他说：看，这都是我挣的。是的，我实现了比经济独立更前一步的独立。这一年，大约近似地算下来，存到了认识的第一个十万；换掉了二十几年的平头发型；空闲时也会自己整两菜，小喝一个。&lt;/p&gt;

&lt;p&gt;去年这时候，我来北京实习。懵懵懂懂。怕犯错，怕被看低，又怕被高估。担心又谨慎。每周六都主动去加班。工作上的努力，多是有回报的，如果没有，换个地方就可以兑换到。在美团的实习经历，助我推开了互联网行业的大门。感谢小伙伴的包容和帮助，理解和支持。去年的元旦晚会，尤其让我感动和敬佩。那一刻，我由衷的感到：”多么高兴和你们在一起共事，多么希望我和你们一样“。只是，以我当时的阅历和水平，显然是不够的。我想留下来，只是不match，挣扎许久。最终，我选择去360，无关对错。&lt;/p&gt;

&lt;p&gt;感谢同组的小伙伴xuetao,runfen,yinrui,xiaobo,zhixiong,zhangqiang，还有老大renqing你们是最棒的团队。在360，我同样幸运的遇上了新的朋友，包容和耐心的AI算法组yuhang,yuanyuan，haide,zeping和 xuesong, 还有数据组的小伙伴。我们一起度过了一段非常美好的时光。于我本人，完成了自己在技术栈上的系统建设。在360实现了个人的快速成长。从零到一的构建了基于深度学习的推荐系统，并成为我简历上闪光的背书。现在我在bat，放空自我，再出发，找寻新的成长点。有过波折，也正在波折中。但是，也因为未知，所以才有无限可能嘛。&lt;/p&gt;

&lt;p&gt;在北京这一年，有经历过凌晨4点的太阳，有经历过被diss的惊恐，有过担心，有过迷茫。但更多是，成长和稳重。感谢北京，感谢坑爹的房东，教会了我隐忍；感谢咄咄逼人的搬家小哥，让我学会了谦逊；感谢北京的冬天，让我知道什么是温暖。&lt;/p&gt;

&lt;p&gt;18年，我和珍珍去见家长了。有点像我来北京之前的面试。有些新鲜，又有些害怕和担心。我们是用吵架开始这一年的。是的，我们有过很大很大的分歧和隔阂；我甚至一度认为，也许你想的和我根本不是一路。“我不会因为你，而改变我的工作方向”，“即使没有你，我也要做我想做的”。讲真，心碎是有声音的。可是，亲爱的，你知道么，遇上你之前。我是准备去读博或者去和老板创业的。讲真，我梦见过很多次回去重新高考，重新读博，梦见我在黑板上推下一行行公式。是的，我放下了它们。因为，一个男票应该有的是，担当。客观地对付现在的生活。&lt;/p&gt;

&lt;p&gt;如果，你觉得，工作内容和方向，能带给你更多的安心，我祝贺你，也祝贺我自己。我们做到了。现在，你是一个正式的算法工程师了。期间，我无数次的心理建设过。我知道，存十万块钱，对我的意义是什么，也清楚那些藏在自己内心深处的悸动。或许，我们是因为太相似，所以才太相惜，却又会在不经意里磕磕碰碰。也许，我们还需要更多的成长。希望，明年会更好吧。希望所有的爱情都有它应有的归宿。&lt;/p&gt;

&lt;p&gt;18年重新和一些很久没联系的同学和朋友联系上了。感受到那穿越时光的明媚，亦体会到那份成人世界里的不堪。不说破，一笑而过。在北京的冬天里，我站在天桥上，看着来来往的车与人群。夜的城市，灯火通明，金光闪闪，天桥上的风从耳旁吹过，冰冷冰冷。止不住的想，于这个城市，我是怎样的一个存在，会怎样，要怎样。有那么一瞬间，我很深刻的体会到研究生宿舍大哥的一句话：是否有一天，旧心酸一笑而过，青春的故事又重新开始。&lt;/p&gt;

&lt;p&gt;走过2018年，走过北漂的一年，新年伊始，总是需要展望下未来一年的。但是，生活从来不会有一个完全ready的状态，时机的落脚点更多的不是机会，而是时间。也就是在任何时候，站出来，迎接挑战。在工作中抽空学习，在学习时不断工作。所以，一年太短，不用事无巨细的计划，好好过好每一天，相信走过的每一步，都是未来回首时，一个个connected dots，就很好啦。&lt;/p&gt;

&lt;p&gt;毕竟成年人的世界，从来没有容易两个字。&lt;/p&gt;

&lt;p&gt;14年，我大学毕业暑假里也是世界杯，在决赛的解说里，有这么一段话：
“这就是本届世界杯最后的篇章，也是华彩的篇章，还有人类情绪中，最高昂的情绪和最低落的情绪交相辉映而成。只有一种情绪绝对够不成丰满，也许只有在失利者落寞的陪伴之下，胜利者才感觉得到幸福的滋味。而我们这些旁观球迷在这样的情感交织之中，终于体会到活着的意味。”&lt;/p&gt;

&lt;p&gt;make every moment count.&lt;/p&gt;

</description>
        <pubDate>Mon, 31 Dec 2018 00:00:00 +0800</pubDate>
        <link>//2018/12/year-of-2018.html</link>
        <guid isPermaLink="true">//2018/12/year-of-2018.html</guid>
        
        <category>Think and Want</category>
        
        
      </item>
    
      <item>
        <title>AUC的定义和原理分析【转】</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://tracholar.github.io/machine-learning/2018/01/26/auc.html&quot;&gt;https://tracholar.github.io/machine-learning/2018/01/26/auc.html&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 03 Dec 2018 00:00:00 +0800</pubDate>
        <link>//2018/12/AUC-Introduction-and-Explanation.html</link>
        <guid isPermaLink="true">//2018/12/AUC-Introduction-and-Explanation.html</guid>
        
        <category>Machine Learning</category>
        
        
      </item>
    
      <item>
        <title>像一个商人一样思考</title>
        <description>&lt;h3 id=&quot;倒卖红枣&quot;&gt;倒卖红枣&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;卖什么？&lt;/li&gt;
  &lt;li&gt;卖给谁？&lt;/li&gt;
  &lt;li&gt;怎么卖？&lt;/li&gt;
  &lt;li&gt;售后、成本？&lt;/li&gt;
  &lt;li&gt;影响力与收益核算。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;基本理念&quot;&gt;基本理念&lt;/h3&gt;

&lt;p&gt;做生意的基本问题就上面几个，思考的顺序也需要如此。永远把产品放在第一位，客户和渠道排在自己前面。产品决定了客户来源，客户决定了渠道和企业收益。企业的根本是产品，核心是客户和渠道。是客户成就了我们，服务好客户是我们企业责任和担当。&lt;/p&gt;

&lt;h4 id=&quot;产品&quot;&gt;产品&lt;/h4&gt;

&lt;p&gt;新疆红枣：&lt;/p&gt;

&lt;h4 id=&quot;客户&quot;&gt;客户&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;挖掘用户群: 什么人会买我的红枣？他们有什么特征？年龄，性别,区域？他们买红枣的主要动机是什么？送人？自己吃？怎么吃？干吃？泡着吃？炖汤？买红枣的时机？&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;主体用户特征: 性别 + 付费意愿 + 需求&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;终端客户：
    &lt;ul&gt;
      &lt;li&gt;$\underline{产品和客户的匹配}$：
        &lt;ul&gt;
          &lt;li&gt;养生：&lt;/li&gt;
          &lt;li&gt;送礼：&lt;/li&gt;
          &lt;li&gt;居家：&lt;/li&gt;
          &lt;li&gt;热水泡&lt;/li&gt;
          &lt;li&gt;干吃&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;中间商：
    &lt;ul&gt;
      &lt;li&gt;赚差价，但是都是服务终端客户&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;渠道&quot;&gt;渠道&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;直销到终端用户: 快递？阶梯价格&lt;/li&gt;
  &lt;li&gt;代销商: 代理？人脉背书，规模。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;售后成本&quot;&gt;售后、成本&lt;/h4&gt;
&lt;p&gt;售后服务的本质是对企业商业系统的监测，我们的系统需要是一个让大家都高兴的系统。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;我们的终端客户是否满意？让终端客户满意，是最根本的问题。如果终端客户不满意，那他们的不满意就会一层层的放大，直到系统崩溃。&lt;/li&gt;
  &lt;li&gt;有没有给合作伙伴带来收益，没有收益的商业合作都是不长久的，只有合作伙伴收益了，我们才能继续合作，继续共赢，继续成长。系统才能成为一个正向的系统。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;收益&quot;&gt;收益&lt;/h4&gt;
&lt;p&gt;永远要在考虑清楚前面几点之后，再来考虑这一点。因为上来就考虑这一点，是不能走多远的，也不是一个正能量的事情。&lt;/p&gt;

&lt;p&gt;核算收益是对企业健康的监测。赔钱赚吆喝的事情，不一定不好，但不能长久。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;直接收益: 总收入减去总支出，净利润是最好的说明。&lt;/li&gt;
  &lt;li&gt;影响力: 未来能获取净利润的预期，品牌，资产，体量等等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这两点需要综合起来看，权衡好比例，才是一个客观的评价。同时，核算好这部分之后，可以一定程度上，调整合作伙伴的收益和用户的体验。但是，一定尽可能在大家满意、合理能接受的基础上调整。&lt;/p&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;用售后检验企业系统的满意程度；用收益检验合理程度。&lt;/p&gt;

</description>
        <pubDate>Fri, 30 Nov 2018 00:00:00 +0800</pubDate>
        <link>//2018/11/Think-Like-A-Bussiness-Man.html</link>
        <guid isPermaLink="true">//2018/11/Think-Like-A-Bussiness-Man.html</guid>
        
        <category>生活开心</category>
        
        
      </item>
    
      <item>
        <title>xgboost原理和源码分析</title>
        <description>&lt;h3 id=&quot;xgboost-原理&quot;&gt;xgboost 原理&lt;/h3&gt;

&lt;h3 id=&quot;源码走读&quot;&gt;源码走读&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cli_main.cc:
main()
     -&amp;gt; CLIRunTask()
          -&amp;gt; CLITrain()
               -&amp;gt; DMatrix::Load()
               -&amp;gt; learner = Learner::Create()
               -&amp;gt; learner-&amp;gt;Configure()
               -&amp;gt; learner-&amp;gt;InitModel()
               -&amp;gt; for (i = 0; i &amp;lt; param.num_round; ++i)
                    -&amp;gt; learner-&amp;gt;UpdateOneIter()
                    -&amp;gt; learner-&amp;gt;Save()    
learner.cc:
Create()
      -&amp;gt; new LearnerImpl()
Configure()
InitModel()
     -&amp;gt; LazyInitModel()
          -&amp;gt; obj_ = ObjFunction::Create()
               -&amp;gt; objective.cc
                    Create()
                         -&amp;gt; SoftmaxMultiClassObj(multiclass_obj.cc)/
                              LambdaRankObj(rank_obj.cc)/
                              RegLossObj(regression_obj.cc)/
                              PoissonRegression(regression_obj.cc)
          -&amp;gt; gbm_ = GradientBooster::Create()
               -&amp;gt; gbm.cc
                    Create()
                         -&amp;gt; GBTree(gbtree.cc)/
                              GBLinear(gblinear.cc)
          -&amp;gt; obj_-&amp;gt;Configure()
          -&amp;gt; gbm_-&amp;gt;Configure()
UpdateOneIter()
      -&amp;gt; PredictRaw()
      -&amp;gt; obj_-&amp;gt;GetGradient()
      -&amp;gt; gbm_-&amp;gt;DoBoost()         
 
gbtree.cc:
Configure()
      -&amp;gt; for (up in updaters)
           -&amp;gt; up-&amp;gt;Init()
DoBoost()
      -&amp;gt; BoostNewTrees()
           -&amp;gt; new_tree = new RegTree()
           -&amp;gt; for (up in updaters)
                -&amp;gt; up-&amp;gt;Update(new_tree)    
 
tree_updater.cc:
Create()
     -&amp;gt; ColMaker/DistColMaker(updater_colmaker.cc)/
        SketchMaker(updater_skmaker.cc)/
        TreeRefresher(updater_refresh.cc)/
        TreePruner(updater_prune.cc)/
        HistMaker/CQHistMaker/
                  GlobalProposalHistMaker/
                  QuantileHistMaker(updater_histmaker.cc)/
        TreeSyncher(updater_sync.cc)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Wed, 28 Nov 2018 00:00:00 +0800</pubDate>
        <link>//2018/11/xgboost-code-review.html</link>
        <guid isPermaLink="true">//2018/11/xgboost-code-review.html</guid>
        
        <category>Machine Learning</category>
        
        
      </item>
    
      <item>
        <title>机器学习-优化器</title>
        <description>&lt;h3 id=&quot;机器学习模型组成&quot;&gt;机器学习模型组成&lt;/h3&gt;

&lt;p&gt;一个机器学习的任务，主要包含以下几个组成部分：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;数据       : $(X,y)$&lt;/li&gt;
  &lt;li&gt;模型函数    : $\hat{y} = f(x)$&lt;/li&gt;
  &lt;li&gt;损失函数    : $L(y,\hat{y})$&lt;/li&gt;
  &lt;li&gt;优化器      : $Optimizer$&lt;/li&gt;
  &lt;li&gt;评估       : $Eval$&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;机器学习任务，可以看作是，$\underline{以数据作为输入，用优化器最小化损失函数，得到模型函数f，用于预估给定的x，并进行评估。}$
一般的，考虑到模型预估的准确和泛化，两个方面的需求，损失函数常被定义成如下形式:&lt;/p&gt;

&lt;p&gt;\begin{equation}
L(y,\hat{y}) = H(y,\hat{y}) + \phi(f(x))
\end{equation}&lt;/p&gt;

&lt;p&gt;其中，$H$, $\phi$ 分别指预测损失和结构损失，前者反映模型预测的准确性，后者是为了保证模型的泛化性能。&lt;/p&gt;

&lt;p&gt;可以看出，模型训练的关键在于最小化损失函数。优化器的选取和对应的原理从而成为关键。&lt;/p&gt;

&lt;h3 id=&quot;从梯度下降法说起&quot;&gt;从梯度下降法说起&lt;/h3&gt;

&lt;p&gt;梯度下降算法是一类应用非常广泛优化方法，属于批量优化算法的一个分支。其思想，尤其简单直接：$\underline{沿着下降速度最快的方向迭代}$&lt;/p&gt;

&lt;p&gt;\begin{equation}
\theta_{n+1} = \theta_{n} - \eta \nabla {J_{\theta}(\theta_{n}) }
\end{equation}&lt;/p&gt;

&lt;p&gt;下面证明 &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
J(\theta_{n+1}) &lt; J(\theta_{n}) %]]&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;\begin{equation}
J(\theta_{n+1}) - J(\theta_{n}) 
= \nabla {J(\theta_{n})(\theta_{n+1} - \theta_{n})} + o(\theta)&lt;br /&gt;
= -\eta \nabla{J(\theta_{n})} \cdot \nabla{J(\theta_{n})} + o(\theta)
= -\eta \nabla J^2(\theta_{n}) + o(\theta) \leq 0
\end{equation}&lt;/p&gt;

&lt;p&gt;根据上面公式可以得到两个结论：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;梯度下降法，在更新步长足够小的情况下(上述证明中用到了中值定理)，是能够逐步优化损失函数值的，得到$J(\theta_{n}) &amp;gt; J(\theta_{n+1}) &amp;gt; J(\theta_{n+2}) &amp;gt; … $&lt;/li&gt;
  &lt;li&gt;因为梯度是当前点下降最快的方向。所以梯度下降法是一个贪心地最快优化方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;学习率&quot;&gt;学习率&lt;/h4&gt;

&lt;p&gt;学习率，亦即步长。是梯度下降法最 trick 的地方：首先，learning_rate 不能太大，因为这个会破坏上面证明中的前提条件（中值定理的前提条件); 然后，learning_rate 不能太小，步长小，更新慢。最后，learning_rate大，除了可能会破坏中值定理的前提条件，也会带来另外的好处，跳出局部最优解。&lt;/p&gt;

&lt;p&gt;所以，一个合理的learning_rate 的选取，要既能够保证收敛，获得一个局部最优解；又能够在几个局部最优解中，选择到最优的那个解。&lt;/p&gt;

&lt;h4 id=&quot;动量&quot;&gt;动量&lt;/h4&gt;

&lt;p&gt;历史更新量，刻画历史更新的方向，对当下更新的影响。能加快收敛，减小震荡。&lt;/p&gt;

&lt;h4 id=&quot;梯度&quot;&gt;梯度&lt;/h4&gt;

&lt;p&gt;当前点的梯度，更新方向的基础量&lt;/p&gt;

&lt;h3 id=&quot;梯度下降框架流程&quot;&gt;梯度下降框架流程&lt;/h3&gt;

&lt;p&gt;梯度下降基本框架和执行流程：&lt;/p&gt;

&lt;p&gt;(1) 计算目标函数关于参数的梯度&lt;/p&gt;

&lt;p&gt;\begin{equation}
g_t = \nabla_{\theta}J(\theta_t)
\end{equation}&lt;/p&gt;

&lt;p&gt;(2) 根据历史梯度计算一阶和二阶动量
\begin{equation}
m_t = \phi(g_1,g_2,g_3,…,g_t)
\end{equation}&lt;/p&gt;

&lt;p&gt;\begin{equation}
v_t = \psi(g_1,g_2,g_3,…,g_t)
\end{equation}&lt;/p&gt;

&lt;p&gt;(3) 更新模型参数
\begin{equation}
\theta_{t+1} = \theta_{t} - \frac{1}{\sqrt{v_t + \epsilon}} m_t
\end{equation}&lt;/p&gt;

&lt;p&gt;其中， $\epsilon$ 为平滑项，防止分母为零，通常取 1e-8。&lt;/p&gt;

&lt;h3 id=&quot;基于框架的算法实例&quot;&gt;基于框架的算法实例&lt;/h3&gt;

&lt;h4 id=&quot;随机梯度下降-sgd&quot;&gt;随机梯度下降 (SGD)&lt;/h4&gt;

&lt;p&gt;学习率$\eta$是固定的，不考虑动量。&lt;/p&gt;

&lt;p&gt;\begin{equation}
\theta_{t} = \theta_{t-1} - \eta g_{t}
\end{equation}&lt;/p&gt;

&lt;h4 id=&quot;动量-momentum-sgd-m&quot;&gt;动量 momentum (SGD-M)&lt;/h4&gt;
&lt;p&gt;相信历史更新的方向，也很有可能是接下来的更新方向: 
\begin{equation}
m_{t} = \lambda m_{t-1}  + \eta g_t 
\end{equation}&lt;/p&gt;

&lt;p&gt;\begin{equation}
\theta_{t} = \theta_{t-1} - m_{t} = \theta_{t-1} - \eta g_{t}  - \lambda m_{t-1}
\end{equation}&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当梯度保持相同方向时，加大步长，加速参数更新；&lt;/li&gt;
  &lt;li&gt;当梯度方向改变时，动量会拉小步长，减缓参数更新。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;带梯度预估的更新方式nag&quot;&gt;带梯度预估的更新方式(NAG)&lt;/h4&gt;
&lt;p&gt;算法能够在目标函数有增高趋势之前，减缓更新速率&lt;/p&gt;

&lt;p&gt;\begin{equation}
g_t = \nabla_\theta J(\theta_t - \gamma m_{t-1})
\end{equation}&lt;/p&gt;

&lt;p&gt;其他步骤和动量momentum保持一致
\begin{equation}
m_t = \gamma m_{t-1} + \eta g_t
\end{equation}&lt;/p&gt;

&lt;p&gt;\begin{equation}
\theta_{t+1} = \theta_t - m_t 
= \theta_t - \eta \nabla_\theta J(\theta_t - \gamma m_{t-1}) - \gamma m_{t-1}
\end{equation}&lt;/p&gt;

&lt;h4 id=&quot;adagrad&quot;&gt;Adagrad&lt;/h4&gt;

&lt;p&gt;SGD、SGD-M 和 NAG 均是以相同的学习率去更新 $\theta$ 的各个分量。而深度学习模型中往往涉及大量的参数，不同参数的更新频率往往有所区别。$\underline{区分对待不同特征的学习率}$. 对于更新不频繁的参数（典型例子：更新 word embedding 中的低频词），我们希望单次步长更大，多学习一些知识；对于更新频繁的参数，我们则希望步长较小，使得学习到的参数更稳定，不至于被单个样本影响太多。&lt;/p&gt;

&lt;p&gt;Adagrad[4] 算法即可达到此效果。其引入了二阶动量：&lt;/p&gt;

&lt;p&gt;\begin{equation}
v_t = \text{diag}(\sum_{s=1}^t g_{s,1}^2, \sum_{s=1}^t g_{s,2}^2, \cdots, \sum_{s=1}^t g_{s,d}^2)
\end{equation}&lt;/p&gt;

&lt;p&gt;其中， $v_t \in \mathbb{R}^{d\times d} $是对角矩阵，其元素 $v_{t, ii}$ 为参数第 $i$维从初始时刻到时刻 $t$ 的梯度平方和。&lt;/p&gt;

&lt;p&gt;\begin{equation}
v_{t, ii} = \sum_{s=1}^t g_{s,i}^2
\end{equation}&lt;/p&gt;

&lt;p&gt;\begin{equation}
\theta_{t+1,i} = \theta_{t,i} - \frac{\eta}{\sqrt{ v_{t, ii}+ \epsilon }} \cdot g_t
\end{equation}
此时，可以这样理解：学习率等效为 $\eta / \sqrt{v_t + \epsilon} $。对于此前频繁更新过的参数，其二阶动量的对应分量较大，学习率就较小。这一方法在稀疏数据的场景下表现很好。&lt;/p&gt;

&lt;h4 id=&quot;rmsprop&quot;&gt;RMSprop&lt;/h4&gt;
&lt;p&gt;在 Adagrad 中， $v_t$ 是单调递增的，使得学习率逐渐递减至 0，可能导致训练过程提前结束。为了改进这一缺点，可以考虑在计算二阶动量时不累积全部历史梯度，而只关注最近某一时间窗口内的下降梯度。根据此思想有了 RMSprop[5]。记 $g_t \odot g_t$ 为 $g_t^2$ ，有
\begin{equation}
v_t = \gamma v_{t-1} + (1-\gamma) \cdot \text{diag}(g_t^2)
\end{equation}
其二阶动量采用指数移动平均公式计算，这样即可避免二阶动量持续累积的问题。和 SGD-M 中的参数类似，$\gamma$ 通常取 0.9 左右。&lt;/p&gt;

&lt;h4 id=&quot;adam&quot;&gt;Adam&lt;/h4&gt;
&lt;p&gt;Adam[6] 可以认为是 RMSprop 和 Momentum 的结合。和 RMSprop 对二阶动量使用指数移动平均类似，Adam 中对一阶动量也是用指数移动平均计算。
\begin{equation}
m_t = \eta[ \beta_1 m_{t-1} + (1 - \beta_1)g_t ]
\end{equation}
\begin{equation}
v_t = \beta_2 v_{t-1} + (1-\beta_2) \cdot \text{diag}(g_t^2)
\end{equation}
其中，初值
$m_0 = 0$, $v_0 = 0$&lt;/p&gt;

&lt;p&gt;注意到，在迭代初始阶段，$m_t$ 和 $v_t$ 有一个向初值的偏移（过多的偏向了 0）。因此，可以对一阶和二阶动量做偏置校正 (bias correction)，
\begin{equation}
\hat{m}_t = \frac{m_t}{1-\beta_1^t}
\end{equation}
\begin{equation}
\hat{v}_t = \frac{v_t}{1-\beta_2^t}
\end{equation}&lt;/p&gt;

&lt;p&gt;再进行更新，
\begin{equation}
\theta_{t+1} = \theta_t - \frac{1}{\sqrt{\hat{v}_t} + \epsilon } \hat{m}_t
\end{equation}&lt;/p&gt;

&lt;p&gt;可以保证迭代较为平稳。&lt;/p&gt;

</description>
        <pubDate>Mon, 26 Nov 2018 00:00:00 +0800</pubDate>
        <link>//2018/11/Optimization-Algorithm-For-Machine-Learning.html</link>
        <guid isPermaLink="true">//2018/11/Optimization-Algorithm-For-Machine-Learning.html</guid>
        
        <category>Machine Learning</category>
        
        
      </item>
    
      <item>
        <title>“解决问题”与“消灭问题”</title>
        <description>&lt;p&gt;一直以来，人们都重视“解决问题”的能力，却忽视了另一种重要的能力：“消灭问题”的能力。各种各样的竞赛，分数和排名，让很多人从小就片面的认为，能“解决问题”的人，就是最厉害的人。拿到一个问题就埋头求解，很少考虑这问题到底有什么意义。这种呆板的思维方式，不仅存在于低级的“应试”和“解题”过程，而且蔓延到了很多艰深的研究领域。&lt;/p&gt;

&lt;p&gt;如果你仔细观察就会发现，很多“难题”，其实是“人造”出来的，而不是“必然”的。它们的存在，往往是由于一些早期的“设计错误”。人造的东西里面往往有设计上的错误，如果你把这些东西看成是不可改变的东西，那你就会遇到很多不必要的问题。打个比方，如果当初轮子被设计成方形的，而没有人质疑这样做的“必要性”，那么也许人类早就因为“能源问题”而灭绝了。有点夸张，但它却形象的说明了，为什么错误的设计会导致不必要的难题。&lt;/p&gt;

&lt;p&gt;其实如果我们转换一下思路，或者改变一下“设计”，很多问题就可以不解自消。这就是我所谓的“消灭问题”的能力。这种“消灭问题”的能力，表面上容易其实难，有点像脑经急转弯，所以经常受到人们的忽视。看到一个问题轻而易举的消失了，总有人满不在乎的说：“这个容易。我也能做到。” 可问题就在于，你怎么没想到？说这种话的人，完全没有意识到，他们的思维里面其实缺少了非常重要的东西。由于喜欢炫耀自己的“头脑暴力”，他们经常解决（甚至制造）错误的问题。&lt;/p&gt;

&lt;p&gt;所以，在解决问题之前，我们应该先问自己三个问题：&lt;/p&gt;

&lt;p&gt;这问题是否真的“存在”？&lt;/p&gt;

&lt;p&gt;也许你已经看出来了，很多问题，即使众人都认为它存在，其实也可能是不存在的。在这一点上不能相信任何人或者机构，不管他有多么的“权威”。就像小马过河的道理，只有靠自己的实践。&lt;/p&gt;

&lt;p&gt;如果解决了这个问题，会给我和他人带来什么实际的好处？&lt;/p&gt;

&lt;p&gt;世界上不存在“永远”，也不存在“无穷”。如果一个“科学算命家”花100年才能算出我的未来，那我还不如坐等“未来”的到来。所有的人，都不过是来这世界上做短暂的旅行。所以，问题的答案，应该能在合理的时间之内给人带来实际的好处。&lt;/p&gt;

&lt;p&gt;这问题是否可以在简单的改变某些“设计”或者“思路”之后，不复存在？&lt;/p&gt;

&lt;p&gt;很多问题的“存在”，其实是因为人们的“思维定势”。他们看不到问题的“根源”和因果关系，而是经常在下意识里假定某种“先决条件”（A）的存在，然后坚定不移的相信由此“导致”的问题（B）的存在，如下图：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; A -----&amp;gt; B
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后，他们开始呆头呆脑的解决 B，完全忘记了质疑 A 存在的必要性。他们从来没有想过，如何消除 A，或者切断 A 与 B 之间的关系。他们没有发现，一旦这前提 A 不复存在，问题 B 就可以不解自消。&lt;/p&gt;

&lt;p&gt;对这一点，我想起一个有趣的故事。有人在饭桌上给大家出了一道“难题”，要他们把自己盘子里的鸡蛋立起来，最后只有一个人做到了。这个人把蛋壳打破了。所有其他人都没有想到这个做法，却说他“犯规”。可是应该检讨的其实应该是他们自己，因为出题的人根本没有说不能打破蛋壳，他们却对此做出了错误的假设。&lt;/p&gt;

&lt;p&gt;我经常发现计算机科学界存在这样的问题。研究了几十年，结果到最后才发现，辛辛苦苦解决的问题，其实包含了错误的假设。如果换一个角度来看，或者稍微改一改设计，这问题就基本不存在了。其中一个例子，就是编译器里面的“语法分析”（parsing）问题。&lt;/p&gt;

&lt;p&gt;语法分析成为一个问题的原因，就在于很多人错误的以为程序语言应该有复杂的语法。正是这些复杂的语法，造成了这个问题研究了很多年，仍然没有一个很好的解决方案。可是一旦语法设计被简化（比如像 Lisp 那样），语法分析就变成一个非常容易的问题。实际上计算机系统（比如 Unix）里的很多问题都是由此引发的，想要利用字符串来进行数据交换，却又设计了一些非常不方便的“数据格式”。简单的语法设计，会让这些问题一并消失掉。关于这个问题，我不想重复发文，细节请见另一篇博文《谈语法)》。&lt;/p&gt;

&lt;p&gt;爱因斯坦说“想象力比知识更重要”，也许就是这个道理。没有想象力的人经常钻牛角尖，走死胡同，忘记了自己其实还有另外的路可走。&lt;/p&gt;

&lt;p&gt;$\underline{转载自王垠博客，此处只是转载}$
&lt;a href=&quot;http://www.yinwang.org/blog-cn/2013/03/19/eliminate-problems&quot;&gt;http://www.yinwang.org/blog-cn/2013/03/19/eliminate-problems&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 19 Oct 2018 00:00:00 +0800</pubDate>
        <link>//2018/10/problem-solver-and-problem-eliminator.html</link>
        <guid isPermaLink="true">//2018/10/problem-solver-and-problem-eliminator.html</guid>
        
        
      </item>
    
      <item>
        <title>路人(转)</title>
        <description>&lt;p&gt;不知为何，
明明想和你说话，却骗你说，
风雨正好，该去写点诗句。&lt;/p&gt;

&lt;p&gt;不必嘲讽我，
你笑出声来 ，我也当是天籁。&lt;/p&gt;

&lt;p&gt;不必怀有敌意，
你所有心计，我都当是你对我的心意。&lt;/p&gt;

&lt;p&gt;我的宿命分为两段，
未遇见你时，和遇见你以后。&lt;/p&gt;

&lt;p&gt;你治好我的忧郁，而后赐我悲伤。
忧郁和悲伤之间的片刻欢喜，
透支了我生命全部的热情储蓄。&lt;/p&gt;

&lt;p&gt;想饮一些酒，让灵魂失重，好被风吹走。&lt;/p&gt;
</description>
        <pubDate>Tue, 16 Oct 2018 00:00:00 +0800</pubDate>
        <link>//2018/10/passby.html</link>
        <guid isPermaLink="true">//2018/10/passby.html</guid>
        
        <category>poem</category>
        
        
      </item>
    
      <item>
        <title>想起一个人(转)</title>
        <description>&lt;p&gt;不可能老是想着你，
你不是我火烧眉毛的生活，
但当闲暇时候，
就会偶尔把你想起。&lt;/p&gt;

&lt;p&gt;想起,
你我站在灵魂的深处，
就这样互相望着，
那么简单，那么美好。&lt;/p&gt;

&lt;p&gt;如果我不是小心忍着，
就要一个人笑出声来。&lt;/p&gt;
</description>
        <pubDate>Tue, 16 Oct 2018 00:00:00 +0800</pubDate>
        <link>//2018/10/friends-and-lovers.html</link>
        <guid isPermaLink="true">//2018/10/friends-and-lovers.html</guid>
        
        
      </item>
    
      <item>
        <title>我心里住的那个人，好像还是他(转)</title>
        <description>&lt;p&gt;2006年的深冬，我和唐耀拽着青春的尾巴，谈了一场众望所归的恋爱。后来我才想起来问自己，喜欢他吗？好像没有。他喜欢我吗？不清楚。哦，似乎连表白这样重要的环节，用的也是省略号。当然，这并不重要，重要的是我们有在一起的必要性。&lt;/p&gt;

&lt;p&gt;百度贴吧里说，要想在人海中，遇到那个和自己同年同月同日生的人，理论上的概率大约为四万分之一。我和唐耀，刚好存在于这样的概率里。如果不发生点什么，还好意思说青春无悔吗？班上同学看我俩的眼神，个个都写着“在一起”。你知道的，那个年纪，喜欢这件事，众人一起哄，总是容易弄假成真。所以，我和唐耀没有经过任何铺垫，就很自然地被划归同一小组做实验，分在同一天做值日，也很自然地被打上了属于对方的标签。&lt;/p&gt;

&lt;p&gt;如果在这个年纪一定要用一场恋爱，来让我的青春锦上添花，那唐耀一定是那朵最好的“花”。有了唐耀，多年后说起青春的时候，我就可以自豪地说，我的初恋是个和我同一天来到这个世界的家伙。瞧，这多拉风。&lt;/p&gt;

&lt;h3 id=&quot;我只想嫁个有钱人&quot;&gt;我只想嫁个有钱人**&lt;/h3&gt;

&lt;p&gt;2007年，我和唐耀的大学隔了一条马路。那时的松江大学城，真是偏僻得让人绝望。开学后，有天我正在宿舍看电影，突然收到唐耀的短信，他用一种看起来平淡温和，实则命令的口气说，明天一起去七宝吧？我对着这几个字发呆，心底竟然升腾起一丝喜悦。&lt;/p&gt;

&lt;p&gt;周末的七宝古镇，耳边是各种调子的吆喝声，我和唐耀随着人流穿梭在街上。这种画面，不由得让我想起书上看过的句子：人群将我们逼为情侣。某个人潮涌动的瞬间，唐耀突然拽住我的手，在我耳边低声嘱咐，不要乱跑。我的心在这句话里，猝不及防地漏掉了一拍。这样的怦然心动，似乎来得有点晚。意识过来的时候，我迅速抽回了手，指着海棠糕说，要不我们吃这个吧？&lt;/p&gt;

&lt;p&gt;黄昏的时候，这座城市飘起小雨。回去的地铁里，更加的人满为患，手脚找不到安身之所。唐耀替我在角落里用双手环住了一个小世界，我们离得如此近，他贴在我耳边，像是自语，又像是问我，为什么我们就不能在一起呢？我低着头不说话。原来真正喜欢上一个人的时候，第一感觉居然是害怕。其实我是个特别现实的女孩子，从小看着父母因为经济拮据吵得天昏地暗，我只想嫁个有钱人。所以，回答唐耀的那个问题，我用的是反问句，四年后你能在这座城市买房吗？唐耀呆立在那，他的眼神如同一盏明灯，被我的这句话，兜头泼了冷水。&lt;/p&gt;

&lt;h3 id=&quot;爱情世界里的穷人&quot;&gt;爱情世界里的穷人**&lt;/h3&gt;

&lt;p&gt;2011年夏天，我有一个家在本地的男友M，一个死命拽着我不让我搬去男友公寓、和她一起租房的闺蜜茉莉，还有一张上外法语专业的学位证。&lt;/p&gt;

&lt;p&gt;这种时候，我常常下意识地想起唐耀。想起他第一次牵我手时紧张的样子，想起他问“为什么我们不能在一起”时悲伤的样子。听说他已经拿到美国某大学的公费留学名额，也听说他这些年一直很拼命。我没想到在他出国前，还能见到他。那天，我和茉莉约在中山公园吃饭。去洗手间时，意外遇到唐耀。我在里面磨磨蹭蹭了十分钟，出来时，还是看到等在原地的他。他看着我，轻轻地问，陈夏，最近好吗？他对你好吗？我没想到唐耀会问第二个问题，刚准备说出口的“挺好”，又缩了回去。打哈哈地明知故问，来这吃饭？“下个月出国，几个朋友聚聚。要不要一起？”“啊，额……好。”&lt;/p&gt;

&lt;p&gt;茉莉说我心底残留着念想，不然鬼才知道为什么我要去凑热闹？我和茉莉走进包厢时，几个男生像是见到熟人一样和我打招呼“陈夏，你好”。而我，明明就不认识他们。&lt;/p&gt;

&lt;p&gt;晚上回到家，茉莉对此的解释是，这还用问吗？唐耀这小子对你用情至深呗，他的那帮兄弟估计都被他拉着倾诉过衷肠。我在这句话里走了神。怎么说呢，也许我和唐耀都是爱情世界里的穷人。&lt;/p&gt;

&lt;h3 id=&quot;醒来觉得甚是想你&quot;&gt;醒来觉得甚是想你**&lt;/h3&gt;

&lt;p&gt;这之后的两三年，发生了很多的事。最大的一件事，是我和M分了手。记得那天深夜，我已经睡下时，M在电话里说，他发烧了，让我帮他去买药。&lt;/p&gt;

&lt;p&gt;窗外是瓢泼大雨，伴着电闪雷鸣，M的公寓离我住的地方不远，但也需要穿过两条街。等了半天打不到车，我只好撑着伞走在深夜的街道上，心里害怕得要死。但你知道吗？当我终于将感冒药送到M家时，他却一脸无辜地说，我就是半夜想吃泡面了，怕你不来帮我煮，所以……&lt;/p&gt;

&lt;p&gt;我看起来像个笑话。我很平静地说了三个字，分手吧。出了小区，我终于忍不住在深夜的大街上哭得像个无助的小孩。过了很久很久，有个出租车师傅大概是看我可怜，主动在我面前停了下来。坐上车，我拨通了那个远在地球另一端的号码。响了一声后，我慌忙摁掉，然后将手机关了机。&lt;/p&gt;

&lt;p&gt;第二天醒来，我收到一条短信：陈夏，是你吗？&lt;/p&gt;

&lt;h3 id=&quot;比大海还深的缘分&quot;&gt;比大海还深的缘分**&lt;/h3&gt;

&lt;p&gt;时间走到2015年的时候，我贷款买了小居室，终于不用带着条条框框去框定我的爱情。我可以爱任何人，不用担心他有没有钱。只是，我相了很多亲，也还是没有遇到意中人。&lt;/p&gt;

&lt;p&gt;我的27岁生日，茉莉一个月前就嚷嚷要帮我庆祝。可临近生日的前一晚，她无比忧伤地说，她男友的一个同事，刚好也是同一天生日，她要代表家属出席。我骂完“重色轻友”，她又凑过来说，不过我们已经找到解决方案，你俩既然是同一天生日，又是我们共同的朋友，不如一起过呗。所以那天晚上，当我推开包厢的门时，便看到了穿得西装革履，像是来赴相亲宴的唐耀。他笑意盈盈地看着我，说：“陈夏，好久不见。”茉莉朝我扮鬼脸，而那些朋友，他们和高中课堂上的同学们一样，看我和唐耀的眼神，个个都写着“在一起”。&lt;/p&gt;

&lt;p&gt;有人感叹，这一定是比大海还深的缘分。可我知道，这世间哪有那么多的久别重逢。很多的重逢是因为我们想要见到对方，才想方设法制造重逢的机会。就像这个生日party，是唐耀和茉莉的精心安排。看《绯闻女孩》时，其中有一幕，Blair对Chuck说，“我不指望你能等我。”Chuck答，“如果两个人注定在一起，最终他们总会找到重温旧梦的路。”眼前这个男人，我想告诉他，见过满天星辰后，我心里住的那个人，好像还是他。&lt;/p&gt;

</description>
        <pubDate>Fri, 12 Oct 2018 00:00:00 +0800</pubDate>
        <link>//2018/10/see-you-again.html</link>
        <guid isPermaLink="true">//2018/10/see-you-again.html</guid>
        
        <category>warm and beautiful</category>
        
        
      </item>
    
  </channel>
</rss>
